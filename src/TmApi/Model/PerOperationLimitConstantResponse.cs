/* 
 * Megaputer Text Mining API
 *
 * Megaputer Text Mining API
 *
 * OpenAPI spec version: 1.0
 * 
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using System.ComponentModel.DataAnnotations;
using OpenAPIDateConverter = TmApi.Client.OpenAPIDateConverter;

namespace TmApi.Model
{
    /// <summary>
    /// PerOperationLimitConstantResponse
    /// </summary>
    [DataContract]
    public partial class PerOperationLimitConstantResponse :  IEquatable<PerOperationLimitConstantResponse>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="PerOperationLimitConstantResponse" /> class.
        /// </summary>
        /// <param name="nTULimit">The maximum number of text units that can be processed in all time.</param>
        /// <param name="nTUTokens">Counter of text units that have been already processed for operation Text parsing.</param>
        /// <param name="nTUKeywords">Counter of text units that have been already processed for operation Keywords extraction.</param>
        /// <param name="nTUEntities">Counter of text units that have been already processed for operation Entities extraction.</param>
        /// <param name="nTULanguages">Counter of text units that have been already processed for operation Language detection.</param>
        /// <param name="nTUSentiments">Counter of text units that have been already processed for operation Sentiments analysis.</param>
        /// <param name="nTUFacts">Counter of text units that have been already processed for operation Facts extraction.</param>
        public PerOperationLimitConstantResponse(int? nTULimit = default(int?), int? nTUTokens = default(int?), int? nTUKeywords = default(int?), int? nTUEntities = default(int?), int? nTULanguages = default(int?), int? nTUSentiments = default(int?), int? nTUFacts = default(int?))
        {
            this.NTULimit = nTULimit;
            this.NTUTokens = nTUTokens;
            this.NTUKeywords = nTUKeywords;
            this.NTUEntities = nTUEntities;
            this.NTULanguages = nTULanguages;
            this.NTUSentiments = nTUSentiments;
            this.NTUFacts = nTUFacts;
        }
        
        /// <summary>
        /// The maximum number of text units that can be processed in all time
        /// </summary>
        /// <value>The maximum number of text units that can be processed in all time</value>
        [DataMember(Name="NTULimit", EmitDefaultValue=false)]
        public int? NTULimit { get; set; }

        /// <summary>
        /// Counter of text units that have been already processed for operation Text parsing
        /// </summary>
        /// <value>Counter of text units that have been already processed for operation Text parsing</value>
        [DataMember(Name="NTUTokens", EmitDefaultValue=false)]
        public int? NTUTokens { get; set; }

        /// <summary>
        /// Counter of text units that have been already processed for operation Keywords extraction
        /// </summary>
        /// <value>Counter of text units that have been already processed for operation Keywords extraction</value>
        [DataMember(Name="NTUKeywords", EmitDefaultValue=false)]
        public int? NTUKeywords { get; set; }

        /// <summary>
        /// Counter of text units that have been already processed for operation Entities extraction
        /// </summary>
        /// <value>Counter of text units that have been already processed for operation Entities extraction</value>
        [DataMember(Name="NTUEntities", EmitDefaultValue=false)]
        public int? NTUEntities { get; set; }

        /// <summary>
        /// Counter of text units that have been already processed for operation Language detection
        /// </summary>
        /// <value>Counter of text units that have been already processed for operation Language detection</value>
        [DataMember(Name="NTULanguages", EmitDefaultValue=false)]
        public int? NTULanguages { get; set; }

        /// <summary>
        /// Counter of text units that have been already processed for operation Sentiments analysis
        /// </summary>
        /// <value>Counter of text units that have been already processed for operation Sentiments analysis</value>
        [DataMember(Name="NTUSentiments", EmitDefaultValue=false)]
        public int? NTUSentiments { get; set; }

        /// <summary>
        /// Counter of text units that have been already processed for operation Facts extraction
        /// </summary>
        /// <value>Counter of text units that have been already processed for operation Facts extraction</value>
        [DataMember(Name="NTUFacts", EmitDefaultValue=false)]
        public int? NTUFacts { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class PerOperationLimitConstantResponse {\n");
            sb.Append("  NTULimit: ").Append(NTULimit).Append("\n");
            sb.Append("  NTUTokens: ").Append(NTUTokens).Append("\n");
            sb.Append("  NTUKeywords: ").Append(NTUKeywords).Append("\n");
            sb.Append("  NTUEntities: ").Append(NTUEntities).Append("\n");
            sb.Append("  NTULanguages: ").Append(NTULanguages).Append("\n");
            sb.Append("  NTUSentiments: ").Append(NTUSentiments).Append("\n");
            sb.Append("  NTUFacts: ").Append(NTUFacts).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as PerOperationLimitConstantResponse);
        }

        /// <summary>
        /// Returns true if PerOperationLimitConstantResponse instances are equal
        /// </summary>
        /// <param name="input">Instance of PerOperationLimitConstantResponse to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(PerOperationLimitConstantResponse input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.NTULimit == input.NTULimit ||
                    (this.NTULimit != null &&
                    this.NTULimit.Equals(input.NTULimit))
                ) && 
                (
                    this.NTUTokens == input.NTUTokens ||
                    (this.NTUTokens != null &&
                    this.NTUTokens.Equals(input.NTUTokens))
                ) && 
                (
                    this.NTUKeywords == input.NTUKeywords ||
                    (this.NTUKeywords != null &&
                    this.NTUKeywords.Equals(input.NTUKeywords))
                ) && 
                (
                    this.NTUEntities == input.NTUEntities ||
                    (this.NTUEntities != null &&
                    this.NTUEntities.Equals(input.NTUEntities))
                ) && 
                (
                    this.NTULanguages == input.NTULanguages ||
                    (this.NTULanguages != null &&
                    this.NTULanguages.Equals(input.NTULanguages))
                ) && 
                (
                    this.NTUSentiments == input.NTUSentiments ||
                    (this.NTUSentiments != null &&
                    this.NTUSentiments.Equals(input.NTUSentiments))
                ) && 
                (
                    this.NTUFacts == input.NTUFacts ||
                    (this.NTUFacts != null &&
                    this.NTUFacts.Equals(input.NTUFacts))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.NTULimit != null)
                    hashCode = hashCode * 59 + this.NTULimit.GetHashCode();
                if (this.NTUTokens != null)
                    hashCode = hashCode * 59 + this.NTUTokens.GetHashCode();
                if (this.NTUKeywords != null)
                    hashCode = hashCode * 59 + this.NTUKeywords.GetHashCode();
                if (this.NTUEntities != null)
                    hashCode = hashCode * 59 + this.NTUEntities.GetHashCode();
                if (this.NTULanguages != null)
                    hashCode = hashCode * 59 + this.NTULanguages.GetHashCode();
                if (this.NTUSentiments != null)
                    hashCode = hashCode * 59 + this.NTUSentiments.GetHashCode();
                if (this.NTUFacts != null)
                    hashCode = hashCode * 59 + this.NTUFacts.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

}
